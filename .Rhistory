tolerance = tolerance,
ext = extension)
shape <-
cbind(data.frame(computeFeatures.shape(nmask)),
data.frame(computeFeatures.moment(nmask))[,1:2]
)
if(!is.null(lower_size)){
shape <- shape[shape$s.area > lower_size, ]
} else{
shape <- shape[shape$s.area > mean(shape$s.area) * 0.01, ]
}
if(!is.null(upper_size)){
shape <- shape[shape$s.area < upper_size, ]
}
shape$id <- 1:nrow(shape)
shape <- shape[, c(9, 7, 8, 1, 2:6)]
} else{
img2 <- channel(img, "gray")
threshold <- otsu(img2)
img2 <- combine(mapply(function(frame, th) frame < th, getFrames(img2), threshold, SIMPLIFY=FALSE))
correct_image(nmask@.Data, perc = 0.2)
nmask <- watershed(distmap(img2),
tolerance = tolerance,
ext = extension)
ID <- which(img2 == 1)
ID2 <- which(img2 == 0)
feat <- computeFeatures.moment(nmask)
}
if(show_original == TRUE){
im2 <- img
} else{
im2 <- colorLabels(nmask)
}
if(show_image == TRUE){
if(mark == "text"){
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
text(shape[,2],
shape[,3],
shape[,1],
col = mark_col,
cex = mark_size)
} else{
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
points(shape[,2],
shape[,3],
col = mark_col,
pch = 16,
cex = mark_size)
}
}
if(save_image == TRUE){
if(dir.exists(diretorio_processada) == FALSE){
dir.create(diretorio_processada)
}
png(paste0(diretorio_processada, "/",
prefix,
name_ori, ".",
extens_ori),
width = dim(im2@.Data)[1],
height = dim(im2@.Data)[2])
if(mark == "text"){
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
text(feat[,1],
feat[,2],
seq(1:nrow(feat)),
col = mark_col,
cex = mark_size)
} else{
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
points(feat[,1],
feat[,2],
col = mark_col,
pch = 16,
cex = mark_size)
}
dev.off()
}
stats <-
data.frame(area = c(n = length(shape$s.area),
min(shape$s.area),
mean(shape$s.area),
max(shape$s.area),
sd(shape$s.area),
sum(shape$s.area)),
perimeter = c(NA,
min(shape$s.perimeter),
mean(shape$s.perimeter),
max(shape$s.perimeter),
sd(shape$s.perimeter),
sum(shape$s.perimeter))) %>%
transform(statistics = c("n", "min", "mean", "max", "sd", "sum"))
stats <- stats[c(3, 1, 2)]
results <- list(results = shape,
statistics = stats)
if(verbose == TRUE){
cat("---------------------------------------------------------------------------\n")
cat("Number of objects:", stats[1,2],"\n")
cat("---------------------------------------------------------------------------\n")
print(stats[-1,], row.names = FALSE)
cat("---------------------------------------------------------------------------\n")
}
invisible(results)
}
if(missing(img_pattern)){
help_count(img, foreground, background, tolerance, extension, randomize,
nrows, show_image, show_original, show_background, mark, mark_col, mark_size, save_image, prefix,
dir_original, dir_processed)
} else{
if(img_pattern %in% c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9")){
img_pattern <- "^[0-9].*$"
}
plants <- list.files(pattern = img_pattern, diretorio_original)
extensions <- as.character(sapply(plants, file_extension))
names_plant <- as.character(sapply(plants, file_name))
if(length(grep(img_pattern, names_plant)) == 0){
stop(paste("'", img_pattern, "' pattern not found in '",
paste(getwd(), sub(".", "", diretorio_original), sep = ""), "'", sep = ""),
call. = FALSE)
}
if(!all(extensions %in% c("png", "jpeg", "jpg", "tiff"))){
stop("Allowed extensions are .png, .jpeg, .jpg, .tiff")
}
results <- list()
pb <- progress(max = length(plants), style = 4)
for (i in 1:length(plants)) {
run_progress(pb, actual = i,
text = paste("Processing image", names_plant[i]))
results[[i]] <-
help_count(img  = names_plant[i],
foreground, background, tolerance, extension, randomize,
nrows, show_image, show_original, show_background, col_background,
save_image, dir_original, dir_processed)
}
names(results) <- names_plant
stats <-
do.call(rbind,
lapply(seq_along(results), function(i){
results[[i]][["statistics"]] %>%
transform(id =  names(results[i])) %>%
.[,c(4, 1, 2, 3)]
})
)
results <-
do.call(rbind,
lapply(seq_along(results), function(i){
results[[i]][["results"]] %>%
transform(img =  names(results[i])) %>%
.[, c(10, 1:9)]
})
)
return(list(statistics = stats,
results = results))
}
}
# count objects
res <-
count_objects(img = "img",
# background ="fundo",
# foreground = "grao",
col_background = "blue",
col_foreground = "gray",
show_segmentation = TRUE)
# count objects
res <-
count_objects(img = "img",
# background ="fundo",
# foreground = "grao",
col_background = "blue",
col_foreground = "gray",
show_original = FALSE,
show_segmentation = TRUE)
#' Counts the number of lesions
#'
#'Counts the number of lesions in a sample or entire leaf based on provided
#'color palettes samples. A general linear model (binomial family) fitted to the
#'RGB values is used to segment the lesions from the healthy leaf. If a pallet
#'of background is provided, the function takes care of the details to isolate
#'it before computing the number and area of lesions. By using `img_pattern` it
#'is possible to process several images with common pattern names that are
#'stored in the current working directory or in the subdirectory informed in
#'`dir_original`.
#' @param img The image to be analyzed.
#' @param background A color palette of the background (optional).
#' @param foreground A color palette of the foreground (optional.
#' @param img_pattern A pattern of file name used to identify images to be
#'   processed. For example, if `img_pattern = "im"` all images that the name
#'   matches the pattern (e.g., img1.-, image1.-, im2.-) will be analyzed.
#'   Providing any number as pattern (e.g., `img_pattern = "1"`) will select
#'   images that are nammed as 1.-, 2.-, and so on.
#' @param lower_size Lower limit for size for the image analysis. Leaf images
#'   often contain dirt and dust. To prevent dust from affecting the image
#'   analysis, the lower limit of analyzed size is set to 0.1, i.e., objects
#'   with lesser than 10% of the mean of all objects are removed. One can set a
#'   known area or use `lower_limit = 0` to select all objects (not advised).
#' @param upper_size Upper limit for size for the image analysis. Defaults to
#'   `NULL`, i.e., no upper limit used.
#' @param randomize Randomize the lines before training the model?
#' @param nrows The number of lines to be used in training step.
#' @param show_image Show image after processing?
#' @param show_original Show the symptoms in the original image?
#' @param show_background Show the background? Defaults to `TRUE`. A white
#'   background is shown by default when `show_original = FALSE`.
#' @param col_foreground Leaf color after image processing. Defaults to `"green"`
#' @param col_foreground Symptoms color after image processing. Defaults to `"red"`.
#' @param col_background Background color after image processing. Defaults to
#'   `"NULL"`.
#' @param mark_col,mark_size,text_digits The color, size and significant digits
#'   used in the text. The shows the pattern `o|a`, where `o` and `a` are the
#'   object id and its area, respectively.
#' @param save_image Save the image after processing? The image is saved in the
#'   current working directory named as `proc_*` where `*` is the image name
#'   given in `img`.
#' @param prefix The prefix to be included in the processed images. Defaults to
#'   `"proc_"`.
#' @param dir_original,dir_processed The directory containing the original and
#'   processed images. Defaults to `NULL`. In this case, the function will
#'   search for the image `img` in the current working directory. After
#'   processing, when `save_image = TRUE`, the processed image will be also
#'   saved in such a directory.
#' @return A data frame with the results for each image.
#' @export
#' @md
#' @examples
#' \donttest{
#' library(pliman)
#' img <- import_image(system.file("tmp_images/sev3.png", package = "pliman"))
#' healthy <- import_image(system.file("tmp_images/sev_healthy.png", package = "pliman"))
#' lesions <- import_image(system.file("tmp_images/sev_sympt.png", package = "pliman"))
#' show_image(img)
#' show_image(healthy)
#' show_image(lesions)
#' count_lesions(img = img,
#'               foreground = healthy,
#'               img_lesion = lesions,
#'               show_image = TRUE)
#' }
#'
count_objects <- function(img,
foreground = NULL,
background = NULL,
img_pattern = NULL,
tolerance = 1,
extension = 10,
lower_size = NULL,
upper_size = NULL,
randomize = TRUE,
nrows = 10000,
show_image = TRUE,
show_original = TRUE,
show_background = TRUE,
show_segmentation = FALSE,
col_foreground = "green",
col_background = "white",
mark = "point",
mark_col = "red",
mark_size = NULL,
save_image = FALSE,
prefix = "proc_",
dir_original = NULL,
dir_processed = NULL,
verbose = TRUE){
if(!missing(img) & !missing(img_pattern)){
stop("Only one of `img` or `img_pattern` arguments can be used.", call. = FALSE)
}
if(is.null(dir_original)){
diretorio_original <- paste("./", sep = "")
} else{
diretorio_original <- paste("./", dir_original, sep = "")
}
if(is.null(dir_processed)){
diretorio_processada <- paste("./", sep = "")
} else{
diretorio_processada <- paste("./", dir_processed, sep = "")
}
help_count <-
function(img, foreground, background, tolerance, extension, randomize,
nrows, show_image, show_original, show_background, mark, mark_col, mark_size, save_image, prefix,
dir_original, dir_processed){
if(is.character(img)){
all_files <- sapply(list.files(diretorio_original), file_name)
check_names_dir(img, all_files, diretorio_original)
imag <- list.files(diretorio_original, pattern = img)
name_ori <- file_name(imag)
extens_ori <- file_extension(imag)
img <- import_image(paste(diretorio_original, "/", name_ori, ".", extens_ori, sep = ""))
} else{
name_ori <- match.call()[[2]]
extens_ori <- "png"
}
if(!is.null(foreground) && !is.null(background)){
if(is.character(foreground)){
all_files <- sapply(list.files(diretorio_original), file_name)
imag <- list.files(diretorio_original, pattern = foreground)
check_names_dir(foreground, all_files, diretorio_original)
name <- file_name(imag)
extens <- file_extension(imag)
foreground <- import_image(paste(diretorio_original, "/", name, ".", extens, sep = ""))
}
if(is.character(background)){
all_files <- sapply(list.files(diretorio_original), file_name)
imag <- list.files(diretorio_original, pattern = background)
check_names_dir(background, all_files, diretorio_original)
name <- file_name(imag)
extens <- file_extension(imag)
background <- import_image(paste(diretorio_original, "/", name, ".", extens, sep = ""))
}
original <- image_to_mat(img, randomize = randomize, nrows = nrows)
foreground <- image_to_mat(foreground, randomize = randomize, nrows = nrows)
background <- image_to_mat(background, randomize = randomize, nrows = nrows)
back_fore <-
rbind(foreground$df_man,
background$df_man) %>%
transform(Y = ifelse(CODE == "background", 0, 1))
modelo1 <-
glm(Y ~ R + G + B, family = binomial("logit"), data = back_fore) %>%
suppressWarnings()
pred1 <- predict(modelo1, newdata = original$df_in, type="response") %>% round(0)
foreground_background <- matrix(pred1, ncol = ncol(original$R))
foreground_background <- correct_image(foreground_background, perc = 0.01)
ID <- c(foreground_background == 1)
ID2 <- c(foreground_background == 0)
nmask <- watershed(distmap(foreground_background),
tolerance = tolerance,
ext = extension)
shape <-
cbind(data.frame(computeFeatures.shape(nmask)),
data.frame(computeFeatures.moment(nmask))[,1:2]
)
if(!is.null(lower_size)){
shape <- shape[shape$s.area > lower_size, ]
} else{
shape <- shape[shape$s.area > mean(shape$s.area) * 0.01, ]
}
if(!is.null(upper_size)){
shape <- shape[shape$s.area < upper_size, ]
}
shape$id <- 1:nrow(shape)
shape <- shape[, c(9, 7, 8, 1, 2:6)]
} else{
img2 <- channel(img, "gray")
threshold <- otsu(img2)
img2 <- combine(mapply(function(frame, th) frame < th, getFrames(img2), threshold, SIMPLIFY=FALSE))
correct_image(nmask@.Data, perc = 0.2)
nmask <- watershed(distmap(img2),
tolerance = tolerance,
ext = extension)
ID <- which(img2 == 1)
ID2 <- which(img2 == 0)
feat <- computeFeatures.moment(nmask)
}
if(show_original == TRUE & show_segmentation == FALSE){
im2 <- img
} else{
if(show_segmentation == TRUE){
im2 <- colorLabels(nmask)
} else{
col_foreground <- col2rgb(col_foreground)
col_background <- col2rgb(col_background)
im2 <- img
im2@.Data[,,1][ID] <- col_foreground[1]
im2@.Data[,,2][ID] <- col_foreground[2]
im2@.Data[,,3][ID] <- col_foreground[3]
im2@.Data[,,1][ID2] <- col_background[1]
im2@.Data[,,2][ID2] <- col_background[2]
im2@.Data[,,3][ID2] <- col_background[3]
}
}
if(show_image == TRUE){
if(mark == "text"){
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
text(shape[,2],
shape[,3],
shape[,1],
col = mark_col,
cex = mark_size)
} else{
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
points(shape[,2],
shape[,3],
col = mark_col,
pch = 16,
cex = mark_size)
}
}
if(save_image == TRUE){
if(dir.exists(diretorio_processada) == FALSE){
dir.create(diretorio_processada)
}
png(paste0(diretorio_processada, "/",
prefix,
name_ori, ".",
extens_ori),
width = dim(im2@.Data)[1],
height = dim(im2@.Data)[2])
if(mark == "text"){
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
text(feat[,1],
feat[,2],
seq(1:nrow(feat)),
col = mark_col,
cex = mark_size)
} else{
mark_size <- ifelse(is.null(mark_size), 0.75, mark_size)
show_image(im2)
points(feat[,1],
feat[,2],
col = mark_col,
pch = 16,
cex = mark_size)
}
dev.off()
}
stats <-
data.frame(area = c(n = length(shape$s.area),
min(shape$s.area),
mean(shape$s.area),
max(shape$s.area),
sd(shape$s.area),
sum(shape$s.area)),
perimeter = c(NA,
min(shape$s.perimeter),
mean(shape$s.perimeter),
max(shape$s.perimeter),
sd(shape$s.perimeter),
sum(shape$s.perimeter))) %>%
transform(statistics = c("n", "min", "mean", "max", "sd", "sum"))
stats <- stats[c(3, 1, 2)]
results <- list(results = shape,
statistics = stats)
if(verbose == TRUE){
cat("---------------------------------------------------------------------------\n")
cat("Number of objects:", stats[1,2],"\n")
cat("---------------------------------------------------------------------------\n")
print(stats[-1,], row.names = FALSE)
cat("---------------------------------------------------------------------------\n")
}
invisible(results)
}
if(missing(img_pattern)){
help_count(img, foreground, background, tolerance, extension, randomize,
nrows, show_image, show_original, show_background, mark, mark_col, mark_size, save_image, prefix,
dir_original, dir_processed)
} else{
if(img_pattern %in% c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9")){
img_pattern <- "^[0-9].*$"
}
plants <- list.files(pattern = img_pattern, diretorio_original)
extensions <- as.character(sapply(plants, file_extension))
names_plant <- as.character(sapply(plants, file_name))
if(length(grep(img_pattern, names_plant)) == 0){
stop(paste("'", img_pattern, "' pattern not found in '",
paste(getwd(), sub(".", "", diretorio_original), sep = ""), "'", sep = ""),
call. = FALSE)
}
if(!all(extensions %in% c("png", "jpeg", "jpg", "tiff"))){
stop("Allowed extensions are .png, .jpeg, .jpg, .tiff")
}
results <- list()
pb <- progress(max = length(plants), style = 4)
for (i in 1:length(plants)) {
run_progress(pb, actual = i,
text = paste("Processing image", names_plant[i]))
results[[i]] <-
help_count(img  = names_plant[i],
foreground, background, tolerance, extension, randomize,
nrows, show_image, show_original, show_background, col_background,
save_image, dir_original, dir_processed)
}
names(results) <- names_plant
stats <-
do.call(rbind,
lapply(seq_along(results), function(i){
results[[i]][["statistics"]] %>%
transform(id =  names(results[i])) %>%
.[,c(4, 1, 2, 3)]
})
)
results <-
do.call(rbind,
lapply(seq_along(results), function(i){
results[[i]][["results"]] %>%
transform(img =  names(results[i])) %>%
.[, c(10, 1:9)]
})
)
return(list(statistics = stats,
results = results))
}
}
# count objects
res <-
count_objects(img = "img",
# background ="fundo",
# foreground = "grao",
col_background = "blue",
col_foreground = "gray",
show_segmentation = TRUE)
# count objects
res <-
count_objects(img = "img",
# background ="fundo",
# foreground = "grao",
col_background = "blue",
col_foreground = "gray",
show_segmentation = FALSE)
